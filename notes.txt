sep 19th:
	got trapping working, now we can try decoding the trap
	reason by reading ESR_EL2 which holds the reason...
	but unfortunately it doesn't hold the key ot my heart

	handle the trap with a dispatcher to find the reason
	and decide the most ILLOGICAL path
	(done)

	resume guest


	setup interrupt stuff cuz qemu just halts the vCPU
	and also translate guest-phys addrs to host-phys addrs
		(stage-2 translation)

	+---------------------------------+
	|          guest (EL1)            |
	| "i want 0x09000000"  			  |
	| (IPA)			                  |
	+---------------------------------+
						   |
		  IPA: 0x09000000  |
						   v
	+---------------------------------+
	|          hypv (EL2)             |
	|        [ stage-2 PTs ]          |
	|  "IPA 0x09000000 maps to PA     |
	|   0x09000000 in my tablez"      |
	+---------------------------------+
				|
				|  PA: 0x09000000
				v
	+---------------------------------+
	|         phys hardware	          |
	|       (UART controller)         |
	+---------------------------------+

sep 20th:
	in guest_mmu_init we set TCR_T0SZ(25)
	but according to the ARMv8 arch TRM a T0SZ
	of val 25 for a 4KiB granule size instructs
	the cpu that the PT walk starts at L1.

	so the hardware would expect the addr to be
	loaded into VTTBR_EL2 and be the base of a L1 PT

	at the moment however we're just creating a 2-level PT
	structure.


testing stuff:
	// uint64_t va_2_pa_el2(uint64_t va);
	/* test func
        for testing mmu purpooses only  */

	// static void mmu_test(void)
	// {
	//     uart_puts("icevmm: mmu translation test\n");

	//     uint64_t va_uart = 0x09000000;
	//     uint64_t pa_uart = va_2_pa_el2(va_uart);
	//     uart_puts("     VA[UART]: "); uart_put_hex(va_uart);
	//     uart_puts("       \n      `------> PA["); uart_put_hex(pa_uart); uart_puts("]\n");

	//     uint64_t va_code = 0x40020000;
	//     uint64_t pa_code = va_2_pa_el2(va_code);
	//     uart_puts("     VA[CODE]: "); uart_put_hex(va_code);
	//     uart_puts("       \n      `------> PA["); uart_put_hex(pa_code); uart_puts("]\n");

	//     uint64_t va_bad = 0x8000000000; /* not mapped in our addr space, but it's valid */
	//     uint64_t pa_bad = va_2_pa_el2(va_bad);
	//     uart_puts("     VA[BAD]:  "); uart_put_hex(va_bad);
	//     uart_puts("       \n      `------> PA["); uart_put_hex(pa_bad); uart_puts("]\n");

	//     if (pa_bad & 1) {
	//             uart_puts("icevmm: translation for VA[BAD] correctly failed !!!\n");
	//     }

	//     uart_puts("icevmm: end test...\n");
	// }